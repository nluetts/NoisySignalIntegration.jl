var documenterSearchIndex = {"docs":
[{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Upon creation, the data types UncertainCurve and UncertainBound use the package MonteCarloMeasurements.jl to generate random samples. Furthermore, integration results are returned as Particle objects from MonteCarloMeasurements which enables you to use MonteCarloMeasurements for further error propagation. Check out the MonteCarloMeasurements.jl documentation to learn more about the sampling process and uncertainty calculations.","category":"page"},{"location":"guide/#Usage-Guide","page":"Usage Guide","title":"Usage Guide","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"As a more detailed usage example, we will go through the analysis of a simulated FTIR spectrum.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"info: A note on plotting\nNoisySignalIntegration provides several \"recipes\" for Plots.jl to easily plot the various (interim) results. Often, merely calling plot() and passing in data types from NoisySignalIntegration will work. Examples are included in this guide.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Suppose our spectrum looks like the following simulation:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"using Distributions, NoisySignalIntegration, Plots\nusing Random: seed!\n\nspectrum = NoisySignalIntegration.testdata_1()\nplot(spectrum, label=\"simulated spectrum\")","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"In order two apply the NoisySignalIntegration uncertainty analysis, we must perform 4 basic steps:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"From the spectrum, crop the region that contains the signals and the region that contains a representative sample of the noise\nCharacterize the noise (to be able to simulate it in the Monte-Carlo draws) \nSet integration bounds and their associated uncertainties\nRun the mc_integrate function","category":"page"},{"location":"guide/#crop","page":"Usage Guide","title":"Cropping the spectrum","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Let's start by dividing the spectrum into the bands we want to integrate and the noise we want to analyse. We can do this by using the crop function.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"slice_bands = crop(spectrum,  5.0,  40.0)\nslice_noise = crop(spectrum, 40.0, 100.0)\n\nplot(slice_bands; label=\"bands\")\nplot!(slice_noise; label=\"noise\")","category":"page"},{"location":"guide/#Noise-analysis","page":"Usage Guide","title":"Noise analysis","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"The spectrum has a quite considerable baseline which constitutes a problem when analysing the noise. To prepare the noise spectrum slice_noise for analysis, we create a NoiseSample object. Upon construction of the NoiseSample object, a polynomial is fitted and subtracted to remove the baseline:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"noise = NoiseSample(slice_noise, 3) # 3 = remove third order polynomial baseline\nnothing # hide","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Plotting the original slice and the NoiseSample object shows the data after baseline removal:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"plot(slice_noise, label=\"cropped noise\")\nplot!(noise, label=\"NoiseSample object\")","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"In order to simulate the noise, we must determine its characteristics. A model is retrieved by fitting the estimated autocovariance:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"nm = fit_noise(noise)\n\n# plot the fitting result:\nplotautocovfit(noise, nm);\n# create zoomed inset:\nlens!([0, 1.5], [-1e-3, 3e-3], inset = (1, bbox(0.3, 0.3, 0.3, 0.3)))","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Plotting the model next to the noise object is an important sanity check to verify that the fitting yielded a sensible estimate and that generated noise samples do mimic the experimental noise.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"plot(noise, nm)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"info: plotting more samples\nThey keyword draws controls how many random generated noise draws are plotted:plot(noise, nm; draws=5) # draw 5 instead of 3 (default) noise drawsThis also works when you plot Monte-Carlo draws.","category":"page"},{"location":"guide/#Preparing-the-spectrum-for-integration","page":"Usage Guide","title":"Preparing the spectrum for integration","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Now that we have a noise model, we can generate an UncertainCurve. An UncertainCurve holds random draws of the original spectrum plus noise:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"uncertain_spectrum = add_noise(slice_bands, nm, 50_000) # generate 50_000 random samples\nnothing # hide","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"If we plot the uncertain_spectrum, we get a ribbon plot showing a 95% confidence band:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"plot(uncertain_spectrum)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"We can also plot single draws by using the mcplot() function from MonteCarloMeasurements.jl:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"using MonteCarloMeasurements\n\nmcplot(uncertain_spectrum; draws=20)","category":"page"},{"location":"guide/#bounds_guide","page":"Usage Guide","title":"Integration bounds","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"NoisySignalIntegration deals with uncertainty in placing integration bounds by expressing each bound by one ore more probability distributions. Any continuous, univariate distribution from Distributions.jl can be used to define integration bounds.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"To define integration bounds, the UncertainBound object is used. There are several options available to create an UncertainBound:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Passing two distributions\nPassing a position, a distribution, and an UncertainCurve\nPassing a vector of positions, a distribution, and an UncertainCurve","category":"page"},{"location":"guide/#Defining-an-UncertainBound-using-a-start-and-end-point","page":"Usage Guide","title":"Defining an UncertainBound using a start and end point","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"If two distributions are passed to UncertainBound(), they will be interpreted as start and end points for the integration window with the uncertainty of these points being expressed by the spread of the distributions.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"For example, let's say we want to integrate the right peak of our simulated spectrum:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"plot(crop(spectrum, 20, 40), label=\"right peak\")\nplot!([27, 32], [1.3, 1.3]; markershape=:cross, label=\"integration interval\")","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"It looks like integrating from about 27 to 32 would be appropriate, but there is some doubt of the exact location of the integration bounds. Perhaps a reasonable estimate is that the left bound falls in the range from 26 to 27 and the right bound in the range from 32 to 33. This would be expressed with a UncertainBound that is defined using two uniform distributions:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"lrb = UncertainBound(Uniform(26, 27), Uniform(32, 33)) # 10 k samples by default\nnothing # hide","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Upon creation of the UncertainBound object, pseudo random samples of the integration start and end point are drawn. If we do not provide the number of samples, it will default to 10 000. We can plot the bound as a histogram to see the distribution of the start and end point:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"histogram(lrb; label=[\"start\" \"end\"])","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"The uniform distribution is of course a bit of an awkward choice, because its probability density suddenly drops to 0, which perhaps does not model one's belief about the position of the integration bounds very well.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Due to the central limit theorem and the general applicability of the normal distribution, it is often a natural choice when dealing with uncertainties:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"lrb_normal = UncertainBound(Normal(26.5, 0.5), Normal(32.5, 0.5), 12_000) # we draw 12_000 samples, just to illustrate how it works\n\nhistogram(lrb_normal; label=[\"start\" \"end\"])","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"However, in this particular case of describing the uncertainty of integration bounds, the tails of the normal distribution are problematic, because they lead to occasional extreme values of the integration interval, which would not seem realistic.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"A compromise between the uniform and normal distribution is a scaled and shifted beta(2, 2) distribution. Its shape resembles the shape of the normal distribution but it is missing the tails. Since a scaled and shifted beta distribution does not ship with Distributions.jl, NoisySignalIntegration includes the function scale_shift_beta(α, β, a, b) which can be used to generate a beta(α, β) distribution that has a support in the interval a to b.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Again, a demonstration may help to explain (we keep the normal distribution for the right bound so we can compare the distributions):","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"lrb_beta_normal = UncertainBound(scale_shift_beta(2, 2, 26, 27), Normal(32.5, 0.5))\n\nhistogram(lrb_beta_normal; label=[\"start\" \"end\"], normalize=true)","category":"page"},{"location":"guide/#Defining-an-UncertainBound-using-a-position,-width,-and-UncertainCurve-(symmetric-bands)","page":"Usage Guide","title":"Defining an UncertainBound using a position, width, and UncertainCurve (symmetric bands)","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"For some spectra, one can assume that a band is more or less symmetric. In this case, it may be better to define an integration window not by a start and end point but merely by a width, and integrate the band symmetrically around its peak position ± half this width.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"To accomplish this, one has to construct an UncertainBound object by passing a position (the peak position of the symmetic band), a distribution that describes the uncertainty in the integration window width (here width_distribution), and an UncertainCurve that holds samples of the spectrum (here uncertain_spectrum):","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"position = 15.0\n # widths will fall in the range 2 to 3, with a maximum at 2.5\nwidth_distribution = scale_shift_beta(2, 2, 2, 3)\n# define a \"width bound\"\nwb = UncertainBound(position, width_distribution, uncertain_spectrum)\nnothing # hide","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"From the provided data, the UncertainBound object is created as follows:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"The width distribution is used to draw as many random samples of the integration window width w as the uncertain_spectrum contains spectral samples\nFor each spectral sample in uncertain_spectrum, the peak position p_x in the range position ± fracw2 is retrieved\nThe peak position p_x is used to define the start and end point of the integration window for each spectral sample, p_x - fracw2 and p_x + fracw2","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Therefore, what is stored in the UncertainBound object are again start and end points for the integration. We can verify this by plotting another histogram:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"histogram(wb; label=[\"start\" \"end\"], normalize=true, linewidth=0)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"The crucial difference compared to the bound defined from two distributions is that the start and end points are now placed symmetrically with respect to the band's peak position. The UncertainBound now \"follows\" the peak in each Monte-Carlo draw, so to speak.","category":"page"},{"location":"guide/#Defining-an-UncertainBound-using-several-positions,-a-width,-and-UncertainCurve-(several-symmetric-bands-with-same-width)","page":"Usage Guide","title":"Defining an UncertainBound using several positions, a width, and UncertainCurve (several symmetric bands with same width)","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"If, for example from a physical argument, we can say that two bands should have the same width, we can constrain our UncertainBounds even further: we can create several bounds that share the exact same integration window width in each draw.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"All we have to do is to provide the constructor of UncertainBound not with a single position, but with an array of several positions:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"positions = [15.0, 30.0]\n\nwb_1, wb_2 = UncertainBound(positions, width_distribution, uncertain_spectrum)\nnothing # hide","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Note that the constructor will then return an array of UncertainBound objects which we unpacked into the variables wb_1 and wb_2 in the example above.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"The histograms of the start and end points looks like this:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"histogram( wb_1; label=[\"start 1\" \"end 1\"], normalize=true, linewidth=0)\nhistogram!(wb_2; label=[\"start 2\" \"end 2\"], normalize=true, linewidth=0)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"It is not obvious from the histograms that the widths of the integration windows stored in wb_1 and wb_2 are identical, so we calculate and print them here manually to prove this:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"for i in 1:10\n    l1 = wb_1.left.particles[i]\n    l2 = wb_2.left.particles[i]\n    r1 = wb_1.right.particles[i]\n    r2 = wb_2.right.particles[i]\n\n    println(\"draw $i: width 1 = \", r1 - l1, \" width 2 = \", r2 - l2)\nend","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"warning: Watch out for the support of your width distribution\nNote that the distribution that you pass to UncertainBound along with a position/positions must not allow for negative values (i.e. its support must end before 0). Keep in mind that a normal distribution, for example, has support from -∞ to ∞, so it is a poor choice here.","category":"page"},{"location":"guide/#plot_mc_draws","page":"Usage Guide","title":"Plotting Monte-Carlo draws","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"To verify that the integration windows and derived integrals are sensible, it is a good idea to plot a few draws and integrals before running the full Monte-Carlo algorithm. We can do so by passing an UncertainCurve and an array of UncertainBounds to the plot function:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"plot(uncertain_spectrum, [wb_1, wb_2]; size=(400, 500), local_baseline=true)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"We can see from the plot that our estimate for the width of the peaks was perhaps a bit too small, so we retry:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"width_distribution = scale_shift_beta(2, 2, 3, 4) # width will fall in the range [3, 4]\nwb_1, wb_2 = UncertainBound(positions, width_distribution, uncertain_spectrum)\n\nplot(uncertain_spectrum, [wb_1, wb_2]; size=(400, 500), local_baseline=true)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"An alternative to the plot function is the animate_draws function which allows you to visualize the Monte-Carlo draws in a gif animation:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"NoisySignalIntegration.animate_draws(\n    uncertain_spectrum, [wb_1, wb_2];\n    size=(300, 150),\n    local_baseline=true\n)","category":"page"},{"location":"guide/#Running-the-integration-algorithm","page":"Usage Guide","title":"Running the integration algorithm","text":"","category":"section"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"The integration is performed with the function mc_integrate. We have to pass in the uncertain spectrum and integration bounds. Since we pass in two integration bounds, we retrieve two areas:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"area_1, area_2 = mc_integrate(uncertain_spectrum, [wb_1, wb_2]; local_baseline=true)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"We can look at the histogram of the integrals:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"histogram([area_1.particles, area_2.particles]; label=[\"band area 1\" \"band area 2\"])","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"Or of the peak area ratio, simply by calculating with the retrieved areas:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"ratio = area_1 / area_2\nhistogram(ratio.particles; label=\"band area ratio (band 1/band 2)\")","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"We see that the histogram of peak area ratio peaks around 0.5, which is what we put into the simulation of the spectrum.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"We can use some basic statistical functions to characterize the result:","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"using StatsBase: mean, std, percentile\n\nmean(ratio)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"std(ratio)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"percentile(ratio, 2.5)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"percentile(ratio, 50)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"percentile(ratio, 97.5)","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"We find that, considering the noise and the uncertainty in the integration bounds, we end up with a 95% uncertainty interval of roughly 0.4 to 0.7.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"info: Sensitivity analysis\nIt is perfectly valid to create several UncertainBounds for one and the same band and feed them into mc_integrate(), e.g. to perform a sensitivity analysis on how much the result depends on the kind and parameters of the bounds.","category":"page"},{"location":"guide/","page":"Usage Guide","title":"Usage Guide","text":"You find more usage examples on the next page. In particular, check out the error propagation example to see how to proceed with uncertainty calculations with the retrieved areas using MonteCarloMeasurements.jl.","category":"page"},{"location":"examples/#Case-studies","page":"Examples","title":"Case studies","text":"","category":"section"},{"location":"examples/#Raman-spectra","page":"Examples","title":"Raman spectra","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Raman spectra are typically measured with a CCD camera where there is no obvious autocorrelation of the noise. The integration works in general as outlined in the Usage Guide. The main difference is the analysis  and generation of noise. Instead of a multivariate MvGaussianNoiseModel, we have to use a GaussianNoiseModel:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# simulate a Raman spectrum with two bands\n\nusing Plots: plot, plot!, histogram\nusing Statistics\nusing MonteCarloMeasurements\n\nusing NoisySignalIntegration\n\n\nspectrum = NoisySignalIntegration.testdata_2()\nplot(spectrum, label=\"simulated spectrum\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# crop the bands and the noise sample\n\nbands = crop(spectrum, 10, 40) - 1 # we can directly subtract 1 from the curve to remove the offset\nnoise = NoiseSample(crop(spectrum, 40, 100), 3)\n\nplot(bands; label=\"bands\")\nplot!(noise; label=\"noise sample\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# build the noise model\n\nnm = noise |> std |> GaussianNoiseModel\n\nuncertain_spectrum = add_noise(bands, nm)\n\nplot(uncertain_spectrum)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# plot some MC draws to check\n\nbounds = UncertainBound([15., 30.], scale_shift_beta(2, 2, 4.5, 5), uncertain_spectrum)\n\nplot(uncertain_spectrum, bounds; size=(500, 600))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# integrate the bands and calculate the ratio\n\narea1, area2 = mc_integrate(uncertain_spectrum, bounds)\n\nhistogram(area1/area2)","category":"page"},{"location":"examples/#Mexican-hat-wavelet","page":"Examples","title":"Mexican hat wavelet","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is more of a basic sanity check for the integration algorithm. The integration of a mexican hat wavelet should yield an integral of 0. For a noisy curve with uncertain integration bounds, the results should still be compatible with an integral of 0, i.e. the 95% confidence interval of the resulting area should include the value 0. If we decrease the noise and the uncertainty in the integration bounds, the result should come closer and closer to 0 (the area distribution should become narrower while still covering the  value 0).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We go once through the regular workflow. First, we generate the test data:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using NoisySignalIntegration\nusing Plots\nusing Random: seed!\n\nseed!(7) # seed for reproducibility\n\nfunction mexican_hat_curve(noise_model)\n    x = -20:0.1:100\n    y = @. (1 - x^2)*exp(-x^2/2)\n    mh = Curve(x, y)\n    uncertain_mh = add_noise(mh, noise_model, 1)\n    return NoisySignalIntegration.get_draw(1, uncertain_mh)\nend\n\nnoisy_mh_curve = mexican_hat_curve(MvGaussianNoiseModel(0.1, 0.05, 0.5))\n\nplot(noisy_mh_curve; label=\"noisy mexican hat\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Analysis of noise:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"noise = NoiseSample(crop(noisy_mh_curve, 5, 100))\nplot(noise; label=\"noise sample\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"noise_model = fit_noise(noise)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plotautocovfit(noise, noise_model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Check that generated noise samples look realistic:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(noise, noise_model; size=(500, 600))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Definition of integration bounds:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"uncertain_mh_curve = add_noise(noisy_mh_curve, noise_model)\n# definition using distributions for start and end point\nbnd = UncertainBound(scale_shift_beta(2, 2, -5, -4), scale_shift_beta(2, 2, 4, 5))\nplot(uncertain_mh_curve, bnd; size=(500, 600), xlim=(-25, 25))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Integration:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"area = mc_integrate(uncertain_mh_curve, bnd)\n\nhistogram(area; label=\"area\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As expected, the mean of the derived areas is close to zero.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we look what happens if we successively decrease the noise level and uncertainty in the integration window position. We define a function that covers the complete integration workflow for a certain scaling factor f that controls the noise level and variability of integration windows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function analyze_noisy_mh(f)\n    noisy_mh_curve = mexican_hat_curve(MvGaussianNoiseModel(0.01, 0.05*f, 0.1))\n    noise = NoiseSample(crop(noisy_mh_curve, 5, 100))\n    noise_model = fit_noise(noise)\n    println(noise_model)\n    uncertain_mh_curve = add_noise(noisy_mh_curve, noise_model)\n    bnd = UncertainBound(scale_shift_beta(2, 2, -4.5-0.5*f, -4.5+0.5*f), scale_shift_beta(2, 2, 4.5-0.5*f, 4.5+0.5*f))\n    return mc_integrate(uncertain_mh_curve, bnd)\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We apply the analysis function to several f factors and plot the histograms of the resulting area distributions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"seed!(2)\n\nareas = [analyze_noisy_mh(f) for f in (1, 0.5, 0.25, 0.05)]\n\nhistogram(\n    [a.particles for a in areas];\n    label=[\"f = 1\" \"f = 0.5\" \"f = 0.25\" \"f = 0.05\"],\n    normalize=true,\n    alpha=0.3,\n    linetype=:stephist,\n    fill=true,\n    xlim=(-1, 1)\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As we can see, with decreasing uncertainty, the result comes closer and closer to 0.","category":"page"},{"location":"examples/#example_propagation","page":"Examples","title":"Error propagation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Since integration results are returned as Particle objects from the MonteCarloMeasurements.jl package (see Internals), calculating combined uncertainties, for example when deriving abundance ratios from band integrals and calculated intensities, is rather simple. Consider the following spectrum with four bands:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# simulate an FTIR spectrum with 4 bands\n\nusing Plots\nusing NoisySignalIntegration\n\nspectrum = NoisySignalIntegration.testdata_4()\nplot(spectrum, label=\"simulated spectrum\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's assume that these bands correspond to 4 different chemical species (species A, B, C and D from left to right) and we know from quantum chemical calculations what the intensity of each band should be per unit of substance. With this information, we can calculate abundance ratios R_xy likes so:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"R_xy = fracA_x  I_xA_y  I_y","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Where A is the band integral and I the calculated intensity for species x or y, respectively.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The uncertainty calculation for the abundance ratio is not straightforward if the distribution of the integrals is asymmetric (which can easily be the case for larger uncertainties). Using MonteCarloMeasurement makes it rather simple, however.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, we integrate with NoisySignalIntegration:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# crop spectrum and noise\nbands = crop(spectrum, 0, 100)\nnoise = NoiseSample(crop(spectrum, 100, 200), 3)\n# retrieve noise model\nnm = fit_noise(noise)\n# prepare spectral samples\nuspec = add_noise(bands, nm)\n# declare integration bounds (several symmetric bands with same width)\nbnds = UncertainBound([15., 30., 60., 85.], scale_shift_beta(2, 2, 4, 6), uspec)\n# integrate\nareas = mc_integrate(uspec, bnds; local_baseline=true)\nA_A, A_B, A_C, A_D = areas","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We inspect the Monte-Carlo draws visually:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(uspec, bnds; size=(500, 600), local_baseline=true)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We put in our calculated intensities and their uncertainties (see MonteCarloMeasurements.jl documentation):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using MonteCarloMeasurements\n\nI_A = @samples 10_000   1 .. 1.1  # uniform distribution (.. operator)\nI_B = @samples 10_000 1.50 ± 0.2  # normal distribution (± operator)\nI_C = @samples 10_000 0.75 ± 0.1\nI_D = @samples 10_000   1 .. 1.1\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"warning: Number of particles must match\nMonteCarloMeasurements.jl propagates uncertainty using a Monte-Carlo process with a specific number of samples called \"particles\". By default, MonteCarloMeasurements.jl produces 2000 particles when defining an uncertain number using the operators ± and .. (as of version 0.9.5). NoisySignalIntegration produces 10000 samples by default. You can use the @samples macro provided by NoisySignalIntegration.jl to increase the number of samples produced by the ± and .. operators as shown in the code example above. The number of samples in all uncertain numbers must match when calculating combined uncertainties with MonteCarloMeasurements.jl, so make sure that this condition is met.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we can simply calculate with the retrieved areas and defined intensities and MonteCarloMeasurements.jl takes care of the uncertainty calculation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"R_BA = (A_B/I_B) / (A_A/I_A)\nR_CA = (A_C/I_C) / (A_A/I_A)\nR_DA = (A_D/I_D) / (A_A/I_A)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This results in the following, displayed as value ± standard deviation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"R_BA","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"R_CA","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"R_DA","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can plot the results as histograms to observe the shape of the distributions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(\n    [R_BA.particles R_CA.particles R_DA.particles],\n    label=[\"B:A\" \"C:A\" \"D:A\"],\n    seriestype=:stephist,\n    normalize=true,\n    xlabel=\"abundance ratio\",\n    ylabel=\"rel. frequency\",\n    xlim=(0, 10),\n    ylim=(0, 2.5),\n    fill=true,\n    layout=(3, 1)\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Clearly, the resulting distributions are asymmetric and non-Gaussian, so the standard deviations do not inform about the level of confidence. You can use StatsBase.jl to calculate percentiles and confidence intervals:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StatsBase: percentile\n\n[percentile(R_BA.particles, p) for p in (2.5, 50, 97.5)]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A visual representation like the histogram may better convey the range of uncertainty, though.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Alternatives are a box plot:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StatsPlots: boxplot\n\nlet\n    rep(str) = repeat([str], length(R_BA.particles)) \n    x = [rep(\"B:A\") rep(\"C:A\") rep(\"D:A\")]\n    y = [R_BA.particles R_CA.particles R_DA.particles]\n    boxplot(x, y, ylabel=\"abundance ratio\", label=nothing)\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Or a violin plot:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StatsPlots: violin\n\nlet\n    rep(str) = repeat([str], length(R_BA.particles)) \n    x = [rep(\"B:A\") rep(\"C:A\") rep(\"D:A\")]\n    y = [R_BA.particles R_CA.particles R_DA.particles]\n    violin(x, y, ylabel=\"abundance ratio\", label=nothing)\nend","category":"page"},{"location":"overview/#Package-Overview","page":"Package Overview","title":"Package Overview","text":"","category":"section"},{"location":"overview/#Workflow","page":"Package Overview","title":"Workflow","text":"","category":"section"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"NoisySignalIntegration.jl estimates the uncertainty in numeric integrals based on the noise level and uncertainty in placing integration bounds. This is achieved by performing the integration many times while varying the noise and integration bounds.","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"The package uses a custom datatype Curve to represent the xy-data that shall be integrated. Curve wraps two vectors of identical element type and length. It was introduced mainly for convenience and simpler plotting.","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"From a Curve object, a NoiseSample can be derived. A NoiseSample is required to determine the noise amplitude and autocorrelation length (if the noise is strongly correlated, as it is often the case in FTIR spectra). With the noise parameters, a noise model can be constructed. This is either a GaussianNoiseModel (uncorrelated Gaussian noise) or an MvGaussianNoiseModel (correlated Gaussian noise, \"Mv\" = multivariate).","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"From the Curve object and noise model, an UncertainCurve object can be constructed. It contains random samples of the original data with varying noise. The UncertainCurve object is the first input required for the actual integration function mc_integrate.","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"tip: Crop your data to the relevant region\nWhile your input dataset should contain a somewhat lengthy portion of noise for the noise analysis step, you should not include this portion of the data in the actual integration, as this will only decrease performance while not offering any benefits. You should always crop your data to only include the relevant signals you want to integrate (see also Usage Guide).","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"The second and last input for the integration function is one or several integration bounds. They are represented by UncertainBound objects which are defined from one or two probability distributions that encode the uncertainty in the integration bounds.","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"In the final step, the mc_integrate function takes the UncertainCurve and UncertainBound(s) and integrates each random sample using the trapezoidal rule. Each UncertainBound yields one uncertain area that is returned as a Particles object from the MonteCarloMeasurements.jl package. Uncertainty propagation with the resulting areas thus works as described in the documentation of MonteCarloMeasurements.jl, merely by performing calculations with Particles objects.","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"tip: Swapping the core integration function\nYou can swap the core integration function that mc_integrate uses to something more accurate, if needed. To do so, pass your integration function as keyword argument intfun. Note, that your integration function needs to have the same call signature as trapz.See also: documentation of mc_integrate.","category":"page"},{"location":"overview/#Data-requirements","page":"Package Overview","title":"Data requirements","text":"","category":"section"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"Due to the internal workings of the package, the input data needs to fulfill some basic requirements:","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"warning: Data must be ordered\nIn general, the data that you analyze must be ordered from low to high x-values. If your data is not ordered, you should run the Base.sort() function on your input data (Curve object) once in the beginning of your analysis:","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"julia> using NoisySignalIntegration\n\njulia> c = Curve([2, 6, 1], [4, 12, 2]);\n\njulia> c = sort(c)\nCurve{Int64}, 3 datapoints\n(1, 2)\n(2, 4)\n(6, 12)","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"warning: x-grid must be uniform when analyzing correlated noise\nCorrelated noise can only be analyzed, if the x-data is evenly spaced. If this is not the case for your input data, you can use Interpolations.jl to interpolate your data on an even x-grid (see in particular here).","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"Example: Interpolating data on evenly spaced grid","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"using NoisySignalIntegration, Interpolations, Plots\n\nc = NoisySignalIntegration.testdata_3() # test dataset with uneven grid spacing\ndiff(c.x) # shows the uneven spacing of x-values ↓↓↓","category":"page"},{"location":"overview/","page":"Package Overview","title":"Package Overview","text":"δx = minimum(diff(c.x))\nx_even = collect(minimum(c.x):δx:maximum(c.x))\ninterp = LinearInterpolation(c.x, c.y)\nc_even = Curve(x_even, interp(x_even))\n\nplot(c; label=\"original data\")\nplot!(c_even; label=\"interpolated data\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"NoisySignalIntegration.jl is available from Github.com.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install it for your project, enter the package mode in the Julia REPL (press ]) and type:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add https://github.com/nluetts/NoisySignalIntegration.jl","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note that the package requires Julia v1.5 or above.","category":"page"},{"location":"#NoisySignalIntegration.jl","page":"Home","title":"NoisySignalIntegration.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NoisySignalIntegration.jl – A tool to determine uncertainty in numeric integrals of noisy data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"NoisySignalIntegration implements a method to determine the uncertainty in numeric integrals of noisy data on the basis of a Monte-Carlo process. A predecessor of this package was originally intended to estimate uncertainties of band signals in FTIR spectra (see G. Karir et al., 2019), which is reflected in the example given in the usage guide.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Table of Contents","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"overview.md\", \"guide.md\", \"examples.md\", \"baseline.md\", \"API.md\", \"internals.md\"]\nDepth = 4","category":"page"},{"location":"baseline/#Baseline-Handling","page":"Baseline Handling","title":"Baseline Handling","text":"","category":"section"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"There are several ways to handle baseline correction when working with the package. The easiest method is to use the build-in local baseline correction which assumes a linear baseline between the start and end point of the integration window. It is envoked by using the keyword argument subtract_baseline (deprecated in v0.2) or local_baseline. The difference of these methods is discussed below.","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"Otherwise, one can subtract a baseline from the data in a preprocessing step. This can be done either before or after generating an UncertainCurve. If a baseline is subtracted from the UncertainCurve, it is possible to account for uncertainty in the baseline correction, e.g. by subtracting baselines generated using a Gaussian process.","category":"page"},{"location":"baseline/#Build-in","page":"Baseline Handling","title":"Build-in","text":"","category":"section"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"Local linear baseline subtraction can be achieved by passing local_baseline=true to the mc_integrate function. To visualize the integrated area, the same keyword argument can be passed to the plot() function when plotting Monte-Carlo draws.","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"The keyword argument subtract_baseline=true is also supported, but its use is deprecated. The difference of local_baseline and subtract_baseline can be visualized when animating draws of curves and integration bound samples (using Plots.@animate): ","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"using NoisySignalIntegration\nusing Plots\nusing Random: seed!\n\nseed!(1)\nnsi = NoisySignalIntegration\n\nlet\n    n = 20\n    c = crop(nsi.testdata_1(), 0, 50)\n    uc = add_noise(c, GaussianNoiseModel(0.1))\n    ubleft = UncertainBound(15.0, scale_shift_beta(2.0, 2.0, 4.0, 5.0), uc)\n    ubright = UncertainBound(30.0, scale_shift_beta(2.0, 2.0, 6.0, 7.0), uc)\n\n    spany = [\n        mm(curve.y for curve ∈ [nsi.get_draw(i, uc) for i ∈ 1:n]) |> mm\n        for mm in (minimum, maximum)\n    ]\n    spany = (spany[1]*0.9, spany[2]*1.1)\n    anim = @animate for i in 1:n\n        kw = Dict(:ylim => spany, :legend => :topleft)\n        p1 = plot(nsi.get_draw(i, uc), [ubleft, ubright], i; subtract_baseline=true, label=[\"subtract_baseline\" \"\" \"\"], kw...)\n        p2 = plot(nsi.get_draw(i, uc), [ubleft, ubright], i; local_baseline=true, label=[\"local_baseline\" \"\" \"\"], kw...)\n        plot(p1, p2; layout=(2, 1), size=(400, 300))\n    end\n    gif(anim, \"baseline_anim.gif\", fps=5)\n    nothing\nend","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"(Image: build-in baseline handling animation)","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"As the figure above shows, the baseline varies considerably more when subtract_baseline is used, compared to local_baseline. The former uses the exact start and end points of the integration window in a particular draw while the latter uses the start and end point distributions to determine a weighted average for y-values at integration bounds of a particular draw. Especially at high noise levels, rather extreme local baseline estimates can follow from using subtract_baseline and the overall uncertainty may be overestimated. It is thus recommended to use the local_baseline method.","category":"page"},{"location":"baseline/#Preprocessing","page":"Baseline Handling","title":"Preprocessing","text":"","category":"section"},{"location":"baseline/#Simple-baseline-subtraction","page":"Baseline Handling","title":"Simple baseline subtraction","text":"","category":"section"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"The data can simply be preprocessed before a Curve object is created. For example, one can mask the signals that shall be integrated (using a filter or calls to the crop and stitch functions) and fit a polynomial or smoothing spline to be subtracted:","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"using NoisySignalIntegration, Plots\ncrv = NoisySignalIntegration.testdata_1()","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"using Polynomials, SmoothingSplines\n\npolyfit, splinefit = let\n    no_signals = stitch(crop(crv, 0, 12), crop(crv, 32, 300)) # remove signals\n    x = no_signals.x\n    y = no_signals.y\n    pfit = Polynomials.fit(x, y, 5)\n    sfit = SmoothingSplines.fit(SmoothingSpline, x, y, 2000.0)\n    pfit, sfit\nend\n\ncrv_baseline_corrected = crv - predict(splinefit, crv.x)\n\nplot(crv; label=\"data\", alpha=0.3, color=:black, legend=:outertopright, size=(800, 400))\nplot!(polyfit, 0, 100; label=\"polynomial baseline fit\")\nplot!(crv.x, predict(splinefit, crv.x); label=\"spline baseline fit\")\nplot!(crv_baseline_corrected; label=\"data - spline baseline\")\n","category":"page"},{"location":"baseline/#Uncertain-baseline","page":"Baseline Handling","title":"Uncertain baseline","text":"","category":"section"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"It may be desirable to account for uncertainty in the subtracted baseline. One way to achieve this is to fit a Gaussian process to the dataset while excluding signals. For example, consider a dataset with a relatively broad band:","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"using NoisySignalIntegration, Plots, Polynomials\n\nbaseline = Polynomial([1, -0.003, 1e-5, 3e-7]).(-150:0.5:150)\nnm = MvGaussianNoiseModel(0.5, 0.1, 1.5);\n\ncrv = NoisySignalIntegration.generate_testdata(\n    0:0.5:300,\n    [(15, 40, 5), (30, 140, 10), (10, 150, 15), (5, 155, 8), (25, 170, 10)],\n    nm;\n    seedvalue=42,\n    baseline=baseline\n)","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"plot(crv, label=nothing)","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"A Gaussian process can be used to approximate the baseline, while allowing for higher uncertainty in the regions where the course of the baseline is masked by signals:","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"using GaussianProcesses, MonteCarloMeasurements\n\ngp = let\n    # cut out signals\n    no_signals = stitch(crop(crv, 0, 25), crop(crv, 55, 110), crop(crv, 200, 300))\n    # fit Gaussian process\n    GP(no_signals.x, no_signals.y, MeanZero(), SE(4.0, 0.1))\nend\n\n# draw random baselines ...\nfs = rand(gp, crv.x, 250)\n\n# ... and plot\nplot(crv.x, fs; alpha=0.05, color=:red, dashed=:dashed, legend=nothing)\nplot!(crv)","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"The \"amplitude\" of the baseline's uncertainty in the range of the signals can be tweaked by the hyperparameters of the Gaussian process, in particular the autocorrelation length scale of the covariance function (in the example SE(), the \"squared exponential\" function, i.e. Gaussian covariance function, with a length scale of 4.0 units).","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"The baseline samples can be subtracted from an UncertainCurve (here ucrv) as follows:","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"# make sure the number of samples matches, here 100 000 samples\nubaseline = rand(gp, crv.x, 100_000) |> transpose |> collect |> Particles\nucrv_baseline_corrected = UncertainCurve(ucrv.x, ucrv.y - ubaseline)","category":"page"},{"location":"baseline/","page":"Baseline Handling","title":"Baseline Handling","text":"The resulting UncertainCurve now includes not only uncertainty due to noise but also due to the baseline correction.","category":"page"},{"location":"API/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"Pages = [\"API.md\"]\nDepth = 4","category":"page"},{"location":"API/#Types","page":"API reference","title":"Types","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"Curve\n\nNoiseSample\n\nUncertainCurve\n\nGaussianNoiseModel\n\nMvGaussianNoiseModel\n\nUncertainBound","category":"page"},{"location":"API/#NoisySignalIntegration.Curve","page":"API reference","title":"NoisySignalIntegration.Curve","text":"Curve{T} <: AbstractCurve\n\nDatatype holding x-y data. x and y vectors have to have the same length.\n\nFields\n\nx :: Vector{T} : x-grid\ny :: Vector{T} : y-values\n\nConstructors\n\nCurve(x, y)\nCurve(y)\n\nNote\n\nBoth x and y must be convertabile to vectors with the same element type.\n\nExamples\n\njulia> Curve([2.0, 3.0], [4.0, 5.0])\nCurve{Float64}, 2 datapoints\n(2.0, 4.0)\n(3.0, 5.0)\n\n\njulia> Curve([2.0, 3.0], [5.0])\nERROR: ArgumentError: x and y need to have the same length.\n[...]\n\n\njulia> Curve([4, 5, 6])\nCurve{Int64}, 3 datapoints\n(1, 4)\n(2, 5)\n(3, 6)\n\n\njulia> Curve(1:3, [1., 2., 3.])\nCurve{Float64}, 3 datapoints\n(1.0, 1.0)\n(2.0, 2.0)\n(3.0, 3.0)\n\n\n\n\n\n","category":"type"},{"location":"API/#NoisySignalIntegration.NoiseSample","page":"API reference","title":"NoisySignalIntegration.NoiseSample","text":"NoiseSample <: AbstractCurve\n\nCurve holding a noise sample. At minimum, a constant offset is removed from the noise sample upon construction. If provided, a polynomial of order n is subtracted.\n\nFields\n\nx::Vector{Float64} : x-grid\ny::Vector{Float64} : y-value\n\nConstructors\n\nNoiseSample(x::Vector{T}, y::Vector{T})\nNoiseSample(x::Vector{T}, y::Vector{T}, n::Int)\nNoiseSample(s::Curve)\nNoiseSample(s::Curve, n::Int)\n\nNotes\n\nNoise samples should not have a slow trend on top of the noise, otherwise noise parameters cannot be reliably infered. Construct NoiseSample objects with a high enough order n so as to remove any slow variations.\n\n\n\n\n\n","category":"type"},{"location":"API/#NoisySignalIntegration.UncertainCurve","page":"API reference","title":"NoisySignalIntegration.UncertainCurve","text":"UncertainCurve{T} <: AbstractCurve\n\nDatatype holding x-y data where y-data holds a vector of particles to model uncertainty. x and y vectors have to have the same length.\n\nFields\n\nx::Vector{T} : x-grid\ny::Vector{Particles{T, N}} : uncertain y-values\n\nConstructors\n\nUncertainCurve(x::Vector{T}, y::Vector{Particles{N, T}})\nUnertainCurve(y::Vector{T})\n\nExamples\n\njulia> using MonteCarloMeasurements\n\n\njulia> UncertainCurve([2.0, 3.0], [4.0 ± 1.0 , 5.0 ± 1.0])\nUncertainCurve{Float64, 2000}, 2 datapoints\n(2.0, 4.0 ± 1.0)\n(3.0, 5.0 ± 1.0)\n\n\njulia> UncertainCurve([2.0], [4.0 ± 1.0 , 5.0 ± 1.0])\nERROR: ArgumentError: x and y need to have the same length.\n[...]\n\n\njulia> UncertainCurve([3.0 ± 1.0, 4.0 ± 1.0 , 5.0 ± 1.0])\nUncertainCurve{Float64, 2000}, 3 datapoints\n(1.0, 3.0 ± 1.0)\n(2.0, 4.0 ± 1.0)\n(3.0, 5.0 ± 1.0)\n\n\n\n\n\n","category":"type"},{"location":"API/#NoisySignalIntegration.GaussianNoiseModel","page":"API reference","title":"NoisySignalIntegration.GaussianNoiseModel","text":"GaussianNoiseModel{T <: Real} <: AbstractNoiseModel\n\nModel to describe noise following a univariate Gaussian distribution (uncorrelated noise).\n\nFields\n\nσ::T : standard deviation\n\n\n\n\n\n","category":"type"},{"location":"API/#NoisySignalIntegration.MvGaussianNoiseModel","page":"API reference","title":"NoisySignalIntegration.MvGaussianNoiseModel","text":"MvGaussianNoiseModel{T <: Real} <: AbstractNoiseModel\n\nModel to describe noise following a multivariate Gaussian distribution (correlated noise).\n\nFields\n\nδx::T: noise grid spacing\nα::T : autocovariance amplitude\nλ::T : autocovaraiance lag\n\n\n\n\n\n","category":"type"},{"location":"API/#NoisySignalIntegration.UncertainBound","page":"API reference","title":"NoisySignalIntegration.UncertainBound","text":"UncertainBound{T, N}\n\nUsed to define uncertain integration bounds.\n\nHolds N samples of start and end points of type T for numeric integration.\n\nFields\n\nleft::Particles{T, N}: samples of starting point\nright::Particles{T, N}: samples of end point\n\nConstructors\n\nUncertainBound(left::S, right::T, N::Int=10_000) where {S <: ContinuousUnivariateDistribution, T <: ContinuousUnivariateDistribution}\n\nCreate an UncertainBound from two distributions left and right defining uncertain start and end points of the integration window.\n\nExample\n\nStart point falls in the range [1, 2] with uniform probability, end point falls in the range [5, 6] with uniform probability:\n\njulia> using Distributions\n\njulia> using Random: seed!; seed!(1);\n\njulia> UncertainBound(Uniform(1, 2), Uniform(5, 6), 20_000)\nUncertainBound{Float64, 20000}(start = 1.5 ± 0.29, end = 5.5 ± 0.29)\n\n\n\nUncertainBound(pos::T, width::ContinuousUnivariateDistribution, uc::UncertainCurve{T, N}) where {T, N}\n\nCreate an UncertainBound from a position pos, a distribution for the integration window width width, and an uncertain curve object uc. Useful for integrating symmetric peaks. The constructor will find start and end points for the integration window such that, for each sample in uc, the integration window will be symmetric around the peak that falls in the interval pos ± (sample of width)/2, i.e. the integration window will \"follow\" the peak position from draw to draw (note that, due to noise, the peak may change its position from draw to draw).\n\nExample\n\nUncertainty of width is modeled with a scaled and shifted Beta(2, 2) distribution:\n\njulia> uc = begin # create uncertain curve with one symmetric peak\n           x = 0:0.1:10;\n           y = @. exp(-(x - 5)^2)\n           add_noise(Curve(x, y), MvGaussianNoiseModel(0.1, 0.03, 0.5))\n       end;\n\njulia> ub = UncertainBound(5., scale_shift_beta(2, 2, 3.5, 4.0), uc)\nUncertainBound{Float64, 10000}(start = 3.12 ± 0.063, end = 6.87 ± 0.064)\n\n\n\nUncertainBound(pos::Vector{T}, width::ContinuousUnivariateDistribution, uc::UncertainCurve{T, N}) where {T, N}\n\nCreate several UncertainBound objects with identical integration window widths in each draw. Useful for integration of several symmetric peaks for which the same width may be assumed.\n\nExample\n\nUncertainty of width is modeled with a scaled and shifted Beta(2, 2) distribution:\n\njulia> uc = begin # create uncertain curve with one symmetric peak\n           x = 0:0.1:10;\n           y = @. exp(-(x - 3)^2/0.15) + exp(-(x - 7)^2/0.15)\n           add_noise(Curve(x, y), MvGaussianNoiseModel(0.1, 0.03, 0.5))\n       end;\n\njulia> ubs = UncertainBound([3., 7.], scale_shift_beta(2, 2, 1.3, 1.5), uc)\n2-element Vector{UncertainBound{Float64, 10000}}:\n UncertainBound{Float64, 10000}(start = 2.3 ± 0.022, end = 3.7 ± 0.022)\n UncertainBound{Float64, 10000}(start = 6.3 ± 0.022, end = 7.7 ± 0.022)\n\n\n\n\n\n","category":"type"},{"location":"API/#Functions","page":"API reference","title":"Functions","text":"","category":"section"},{"location":"API/#Manipulation-of-Curves","page":"API reference","title":"Manipulation of Curves","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"crop\n\nstitch\n\nadd_noise","category":"page"},{"location":"API/#NoisySignalIntegration.crop","page":"API reference","title":"NoisySignalIntegration.crop","text":"crop(s::AbstractCurve, left, right)\n\nCrop a slice from a curve between left and right and return a new curve.\n\nExamples\n\njulia> c = Curve(1:0.5:10, 11:0.5:20)\nCurve{Float64}, 19 datapoints\n(1.0, 11.0)\n(1.5, 11.5)\n(2.0, 12.0)\n(2.5, 12.5)\n(3.0, 13.0)\n    ⋮\n(8.0, 18.0)\n(8.5, 18.5)\n(9.0, 19.0)\n(9.5, 19.5)\n(10.0, 20.0)\n\n\njulia> crop(c, 2, 3)\nCurve{Float64}, 3 datapoints\n(2.0, 12.0)\n(2.5, 12.5)\n(3.0, 13.0)\n\n\njulia> crop(c, 2.1, 3.5)\nCurve{Float64}, 3 datapoints\n(2.5, 12.5)\n(3.0, 13.0)\n(3.5, 13.5)\n\n\njulia> crop(c, 2.1, 3.9)\nCurve{Float64}, 3 datapoints\n(2.5, 12.5)\n(3.0, 13.0)\n(3.5, 13.5)\n\n\njulia> crop(c, 2.1, 4.0)\nCurve{Float64}, 4 datapoints\n(2.5, 12.5)\n(3.0, 13.0)\n(3.5, 13.5)\n(4.0, 14.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#NoisySignalIntegration.stitch","page":"API reference","title":"NoisySignalIntegration.stitch","text":"stitch(curves...)\n\nAppend curves one after the other.\n\nUseful when cutting out signals from Curves for baseline correction purposes.\n\n\n\n\n\n","category":"function"},{"location":"API/#NoisySignalIntegration.add_noise","page":"API reference","title":"NoisySignalIntegration.add_noise","text":"add_noise(c::Curve, nm::AbstractNoiseModel, N::Int=10_000)\n\nAdd noise from noise model to curve, retrieve UncertainCurve with N samples.\n\n\n\n\n\n","category":"function"},{"location":"API/#Noise-analysis","page":"API reference","title":"Noise analysis","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"fit_noise\n\nplotautocovfit\n","category":"page"},{"location":"API/#NoisySignalIntegration.fit_noise","page":"API reference","title":"NoisySignalIntegration.fit_noise","text":"fit_noise(ns::NoiseSample; α_guess=1.0, λ_guess=1.0)\n\nBuild a MvGaussianNoiseModel for the NoiseSample ns.\n\nEstimates parameters α and λ by fitting the exponentiated quadratic covariance function\n\nk(Δx) = α² exp(-0.5 (Δx/λ)²)\n\nto the autocovariance (k) vs. the lag (Δx) of the noise sample.\n\nChange initial guess if fit does not converge to sensible result.\n\n\n\n\n\n","category":"function"},{"location":"API/#NoisySignalIntegration.plotautocovfit","page":"API reference","title":"NoisySignalIntegration.plotautocovfit","text":"plotautocovfit(ns::NoiseSample, nm::MvGaussianNoiseModel; kw...)\n\nPlot results of autocovariance fit.\n\n\n\n\n\n","category":"function"},{"location":"API/#Statistics","page":"API reference","title":"Statistics","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"scale_shift_beta","category":"page"},{"location":"API/#NoisySignalIntegration.scale_shift_beta","page":"API reference","title":"NoisySignalIntegration.scale_shift_beta","text":"scale_shift_beta(α, β, a, b)\n\nCreate a scaled and shifted Beta(α, β) distribution. Samples fall in the interval [a, b].\n\n\n\n\n\n","category":"function"},{"location":"API/#Integration","page":"API reference","title":"Integration","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"mc_integrate\n\ntrapz","category":"page"},{"location":"API/#NoisySignalIntegration.mc_integrate","page":"API reference","title":"NoisySignalIntegration.mc_integrate","text":"mc_integrate(uc::UncertainCurve{T, N}, bnds::Vector{UncertainBound{T, M}}; intfun=trapz)\nmc_integrate(uc::UncertainCurve{T, N}, bnds::UncertainBound{T, M}; intfun=trapz)\n\nIntegrate uncertain curve using uncertain bound(s).\n\nApplies Monte-Carlo integration algorithm to samples stored in uc and returns one or an array of uncertain areas of type Particles{T, N}.\n\nKeyword arguments\n\nintfun: The core integration function that is used to numerically integrate each draw. Defaults to NoisySignalIntegration.trapz. The function that is used to substitute trapz must share its call signature.\n\nsubtract_baseline (deprecated in favor of local_baseline): If true, for each draw a local linear baseline defined by the integration window start and end point will be subtracted.\n\nlocal_baseline: If true, for each draw a local linear baseline defined by the integration window start and end point will be subtracted. The y-values of the start and end point are derived from a weighted average over the start and end point distributions, see  the documentation for further information.\n\n\n\n\n\n","category":"function"},{"location":"API/#NoisySignalIntegration.trapz","page":"API reference","title":"NoisySignalIntegration.trapz","text":"trapz(x::AbstractArray{T}, y::AbstractArray{T}, left, right) where {T<:AbstractFloat}\n\nIntegrate vector y in interval [left, right] using trapezoidal integration.\n\nNotes\n\nleft and right must support conversion to the datatype T.\n\nIf left and right do not fall on the x-grid, additional data points will be interpolated linearly. (i.e. the width of the first and last trapezoid will be somewhat smaller).\n\nIf left and/or right falls outside the x-range, the integration window will be cropped to the available range.\n\nExamples\n\njulia> x = collect(Float64, 0:10);\n\njulia> y = ones(Float64, 11);\n\n\njulia> trapz(x, y, 1, 3)\n2.0\n\n\njulia> trapz(x, y, -1, 11) # at most, we can integrate the available x-range, 0 to 10\n10.0\n\n\njulia> trapz(x, y, -10, 20)\n10.0\n\n\njulia> trapz(x, y, 1.1, 1.3) ≈ 0.2 # if we integrate \"between\" the grid, data points are interpolated\ntrue\n\n\n\n\n\n","category":"function"},{"location":"API/#Macros","page":"API reference","title":"Macros","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"@samples","category":"page"},{"location":"API/#NoisySignalIntegration.@samples","page":"API reference","title":"NoisySignalIntegration.@samples","text":"@samples n::Integer e::Expression\n\nCreate a Particles object with n samples using a ± or .. expression.\n\nExamples\n\njulia> using NoisySignalIntegration\n\njulia> @samples 9999 1 ± 1\nMonteCarloMeasurements.Particles{Float64, 9999}\n 1.0 ± 1.0\n\n\njulia> @samples 9999 1 .. 2\nMonteCarloMeasurements.Particles{Float64, 9999}\n 1.5 ± 0.289\n\n\n\n\n\n","category":"macro"},{"location":"API/#Misc","page":"API reference","title":"Misc","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"animate_draws","category":"page"},{"location":"API/#NoisySignalIntegration.animate_draws","page":"API reference","title":"NoisySignalIntegration.animate_draws","text":"animate_draws(uc::UncertainCurve, bnds::Vector{UncertainBound}; n=20, fps=5, filepath=nothing, kw...)\n\nCreate a gif animation showing the first n random draws. Requires the Plots.jl package.\n\nCreate an animation of the Monte-Carlo iterations when integrating the UncertainCurve uc using the UncertainBounds bnds.\n\nKeyword arguments\n\nn: number of draws that are included in animation\n\nfps: frames-per-second\n\nfilepath: if provided, the gif-animation will be stored using this filepath, otherwise a temporary file will be created.\n\nFurther keyword arguments are passed on the Plots.plot() function.\n\n\n\n\n\n","category":"function"}]
}
