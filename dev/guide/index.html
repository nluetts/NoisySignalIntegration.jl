<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage Guide · NoisySignalIntegration.jl</title><meta name="title" content="Usage Guide · NoisySignalIntegration.jl"/><meta property="og:title" content="Usage Guide · NoisySignalIntegration.jl"/><meta property="twitter:title" content="Usage Guide · NoisySignalIntegration.jl"/><meta name="description" content="Documentation for NoisySignalIntegration.jl."/><meta property="og:description" content="Documentation for NoisySignalIntegration.jl."/><meta property="twitter:description" content="Documentation for NoisySignalIntegration.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NoisySignalIntegration.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">NoisySignalIntegration.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../overview/">Package Overview</a></li><li class="is-active"><a class="tocitem" href>Usage Guide</a><ul class="internal"><li><a class="tocitem" href="#crop"><span>Cropping the spectrum</span></a></li><li><a class="tocitem" href="#Noise-analysis"><span>Noise analysis</span></a></li><li><a class="tocitem" href="#Preparing-the-spectrum-for-integration"><span>Preparing the spectrum for integration</span></a></li><li><a class="tocitem" href="#bounds_guide"><span>Integration bounds</span></a></li><li><a class="tocitem" href="#plot_mc_draws"><span>Plotting Monte-Carlo draws</span></a></li><li><a class="tocitem" href="#Running-the-integration-algorithm"><span>Running the integration algorithm</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../baseline/">Baseline Handling</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../API/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/nluetts/NoisySignalIntegration.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/nluetts/NoisySignalIntegration.jl/blob/master/docs/src/guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage-Guide"><a class="docs-heading-anchor" href="#Usage-Guide">Usage Guide</a><a id="Usage-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-Guide" title="Permalink"></a></h1><p>As a more detailed usage example, we will go through the analysis of a simulated FTIR spectrum.</p><div class="admonition is-info"><header class="admonition-header">A note on plotting</header><div class="admonition-body"><p><code>NoisySignalIntegration</code> provides several &quot;<a href="http://docs.juliaplots.org/latest/recipes/">recipes</a>&quot; for <a href="http://docs.juliaplots.org/latest/"><code>Plots.jl</code></a> to easily plot the various (interim) results. Often, merely calling <code>plot()</code> and passing in data types from <code>NoisySignalIntegration</code> will work. Examples are included in this guide.</p></div></div><p>Suppose our spectrum looks like the following simulation:</p><pre><code class="language-julia hljs">using Distributions, NoisySignalIntegration, Plots
using Random: seed!

spectrum = NoisySignalIntegration.testdata_1()
plot(spectrum, label=&quot;simulated spectrum&quot;)</code></pre><img src="bf3e188e.svg" alt="Example block output"/><p>In order two apply the <code>NoisySignalIntegration</code> uncertainty analysis, we must perform 4 basic steps:</p><ol><li>From the spectrum, crop the region that contains the signals and the region that contains a representative sample of the noise</li><li>Characterize the noise (to be able to simulate it in the Monte-Carlo draws) </li><li>Set integration bounds and their associated uncertainties</li><li>Run the <a href="../API/#NoisySignalIntegration.mc_integrate"><code>mc_integrate</code></a> function</li></ol><h2 id="crop"><a class="docs-heading-anchor" href="#crop">Cropping the spectrum</a><a id="crop-1"></a><a class="docs-heading-anchor-permalink" href="#crop" title="Permalink"></a></h2><p>Let&#39;s start by dividing the spectrum into the bands we want to integrate and the noise we want to analyse. We can do this by using the <a href="../API/#NoisySignalIntegration.crop"><code>crop</code></a> function.</p><pre><code class="language-julia hljs">slice_bands = crop(spectrum,  5.0,  40.0)
slice_noise = crop(spectrum, 40.0, 100.0)

plot(slice_bands; label=&quot;bands&quot;)
plot!(slice_noise; label=&quot;noise&quot;)</code></pre><img src="6ad046b7.svg" alt="Example block output"/><h2 id="Noise-analysis"><a class="docs-heading-anchor" href="#Noise-analysis">Noise analysis</a><a id="Noise-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Noise-analysis" title="Permalink"></a></h2><p>The spectrum has a quite considerable baseline which constitutes a problem when analysing the noise. To prepare the noise spectrum <code>slice_noise</code> for analysis, we create a <a href="../API/#NoisySignalIntegration.NoiseSample"><code>NoiseSample</code></a> object. Upon construction of the <code>NoiseSample</code> object, a polynomial is fitted and subtracted to remove the baseline:</p><pre><code class="language-julia hljs">noise = NoiseSample(slice_noise, 3) # 3 = remove third order polynomial baseline</code></pre><p>Plotting the original slice and the <code>NoiseSample</code> object shows the data after baseline removal:</p><pre><code class="language-julia hljs">plot(slice_noise, label=&quot;cropped noise&quot;)
plot!(noise, label=&quot;NoiseSample object&quot;)</code></pre><img src="8b7c8ba5.svg" alt="Example block output"/><p>In order to simulate the noise, we must determine its characteristics. A model is retrieved by fitting the estimated autocovariance:</p><pre><code class="language-julia hljs">nm = fit_noise(noise)

# plot the fitting result:
plotautocovfit(noise, nm);
# create zoomed inset:
lens!([0, 1.5], [-1e-3, 3e-3], inset = (1, bbox(0.3, 0.3, 0.3, 0.3)))</code></pre><img src="6e58bf49.svg" alt="Example block output"/><p>Plotting the model next to the noise object is an important sanity check to verify that the fitting yielded a sensible estimate and that generated noise samples do mimic the experimental noise.</p><pre><code class="language-julia hljs">plot(noise, nm)</code></pre><img src="8daba3dc.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">plotting more samples</header><div class="admonition-body"><p>They keyword <code>draws</code> controls how many random generated noise draws are plotted:</p><pre><code class="language-julia hljs">plot(noise, nm; draws=5) # draw 5 instead of 3 (default) noise draws</code></pre><p>This also works when you <a href="#plot_mc_draws">plot Monte-Carlo draws</a>.</p></div></div><h2 id="Preparing-the-spectrum-for-integration"><a class="docs-heading-anchor" href="#Preparing-the-spectrum-for-integration">Preparing the spectrum for integration</a><a id="Preparing-the-spectrum-for-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Preparing-the-spectrum-for-integration" title="Permalink"></a></h2><p>Now that we have a noise model, we can generate an <a href="../API/#NoisySignalIntegration.UncertainCurve"><code>UncertainCurve</code></a>. An <code>UncertainCurve</code> holds random draws of the original spectrum plus noise:</p><pre><code class="language-julia hljs">uncertain_spectrum = add_noise(slice_bands, nm, 50_000) # generate 50_000 random samples</code></pre><p>If we plot the <code>uncertain_spectrum</code>, we get a ribbon plot showing a 95% confidence band:</p><pre><code class="language-julia hljs">plot(uncertain_spectrum)</code></pre><img src="3fb132a3.svg" alt="Example block output"/><p>We can also plot single draws by using the <code>mcplot()</code> function from <code>MonteCarloMeasurements.jl</code>:</p><pre><code class="language-julia hljs">using MonteCarloMeasurements

mcplot(uncertain_spectrum; draws=20)</code></pre><img src="70d0de45.svg" alt="Example block output"/><h2 id="bounds_guide"><a class="docs-heading-anchor" href="#bounds_guide">Integration bounds</a><a id="bounds_guide-1"></a><a class="docs-heading-anchor-permalink" href="#bounds_guide" title="Permalink"></a></h2><p><code>NoisySignalIntegration</code> deals with uncertainty in placing integration bounds by expressing each bound by one ore more probability distributions. Any continuous, univariate distribution from <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a> can be used to define integration bounds.</p><p>To define integration bounds, the <code>UncertainBound</code> object is used. There are several options available to create an <code>UncertainBound</code>:</p><ol><li>Passing two distributions</li><li>Passing a position, a distribution, and an <code>UncertainCurve</code></li><li>Passing a vector of positions, a distribution, and an <code>UncertainCurve</code></li></ol><h3 id="Defining-an-UncertainBound-using-a-start-and-end-point"><a class="docs-heading-anchor" href="#Defining-an-UncertainBound-using-a-start-and-end-point">Defining an <code>UncertainBound</code> using a start and end point</a><a id="Defining-an-UncertainBound-using-a-start-and-end-point-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-an-UncertainBound-using-a-start-and-end-point" title="Permalink"></a></h3><p>If two distributions are passed to <code>UncertainBound()</code>, they will be interpreted as start and end points for the integration window with the uncertainty of these points being expressed by the spread of the distributions.</p><p>For example, let&#39;s say we want to integrate the right peak of our simulated spectrum:</p><pre><code class="language-julia hljs">plot(crop(spectrum, 20, 40), label=&quot;right peak&quot;)
plot!([27, 32], [1.3, 1.3]; markershape=:cross, label=&quot;integration interval&quot;)</code></pre><img src="2fe63bef.svg" alt="Example block output"/><p>It looks like integrating from about 27 to 32 would be appropriate, but there is some doubt of the exact location of the integration bounds. Perhaps a reasonable estimate is that the left bound falls in the range from 26 to 27 and the right bound in the range from 32 to 33. This would be expressed with a <code>UncertainBound</code> that is defined using two uniform distributions:</p><pre><code class="language-julia hljs">lrb = UncertainBound(Uniform(26, 27), Uniform(32, 33)) # 10 k samples by default</code></pre><p>Upon creation of the <code>UncertainBound</code> object, pseudo random samples of the integration start and end point are drawn. If we do not provide the number of samples, it will default to 10 000. We can plot the bound as a histogram to see the distribution of the start and end point:</p><pre><code class="language-julia hljs">histogram(lrb; label=[&quot;start&quot; &quot;end&quot;])</code></pre><img src="849abf07.svg" alt="Example block output"/><p>The uniform distribution is of course a bit of an awkward choice, because its probability density suddenly drops to 0, which perhaps does not model one&#39;s belief about the position of the integration bounds very well.</p><p>Due to the central limit theorem and the general applicability of the normal distribution, it is often a natural choice when dealing with uncertainties:</p><pre><code class="language-julia hljs">lrb_normal = UncertainBound(Normal(26.5, 0.5), Normal(32.5, 0.5), 12_000) # we draw 12_000 samples, just to illustrate how it works

histogram(lrb_normal; label=[&quot;start&quot; &quot;end&quot;])</code></pre><img src="e8537a11.svg" alt="Example block output"/><p>However, in this particular case of describing the uncertainty of integration bounds, the tails of the normal distribution are problematic, because they lead to occasional extreme values of the integration interval, which would not seem realistic.</p><p>A compromise between the uniform and normal distribution is a scaled and shifted beta(2, 2) distribution. Its shape resembles the shape of the normal distribution but it is missing the tails. Since a scaled and shifted beta distribution does not ship with <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a>, <code>NoisySignalIntegration</code> includes the function <a href="../API/#NoisySignalIntegration.scale_shift_beta"><code>scale_shift_beta</code></a><code>(α, β, a, b)</code> which can be used to generate a beta(α, β) distribution that has a support in the interval <code>a</code> to <code>b</code>.</p><p>Again, a demonstration may help to explain (we keep the normal distribution for the right bound so we can compare the distributions):</p><pre><code class="language-julia hljs">lrb_beta_normal = UncertainBound(scale_shift_beta(2, 2, 26, 27), Normal(32.5, 0.5))

histogram(lrb_beta_normal; label=[&quot;start&quot; &quot;end&quot;], normalize=true)</code></pre><img src="bb03ca6b.svg" alt="Example block output"/><h3 id="Defining-an-UncertainBound-using-a-position,-width,-and-UncertainCurve-(symmetric-bands)"><a class="docs-heading-anchor" href="#Defining-an-UncertainBound-using-a-position,-width,-and-UncertainCurve-(symmetric-bands)">Defining an <code>UncertainBound</code> using a position, width, and <code>UncertainCurve</code> (symmetric bands)</a><a id="Defining-an-UncertainBound-using-a-position,-width,-and-UncertainCurve-(symmetric-bands)-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-an-UncertainBound-using-a-position,-width,-and-UncertainCurve-(symmetric-bands)" title="Permalink"></a></h3><p>For some spectra, one can assume that a band is more or less symmetric. In this case, it may be better to define an integration window not by a start and end point but merely by a width, and integrate the band symmetrically around its peak position ± half this width.</p><p>To accomplish this, one has to construct an <code>UncertainBound</code> object by passing a <code>position</code> (the peak position of the symmetic band), a distribution that describes the uncertainty in the integration window width (here <code>width_distribution</code>), and an <code>UncertainCurve</code> that holds samples of the spectrum (here <code>uncertain_spectrum</code>):</p><pre><code class="language-julia hljs">position = 15.0
 # widths will fall in the range 2 to 3, with a maximum at 2.5
width_distribution = scale_shift_beta(2, 2, 2, 3)
# define a &quot;width bound&quot;
wb = UncertainBound(position, width_distribution, uncertain_spectrum)</code></pre><p>From the provided data, the <code>UncertainBound</code> object is created as follows:</p><ul><li>The width distribution is used to draw as many random samples of the integration window width <span>$w$</span> as the <code>uncertain_spectrum</code> contains spectral samples</li><li>For each spectral sample in <code>uncertain_spectrum</code>, the peak position <span>$p_x$</span> in the range <code>position</code> ± <span>$\frac{w}{2}$</span> is retrieved</li><li>The peak position <span>$p_x$</span> is used to define the start and end point of the integration window for each spectral sample, <span>$p_x - \frac{w}{2}$</span> and <span>$p_x + \frac{w}{2}$</span></li></ul><p>Therefore, what is stored in the <code>UncertainBound</code> object are again start and end points for the integration. We can verify this by plotting another histogram:</p><pre><code class="language-julia hljs">histogram(wb; label=[&quot;start&quot; &quot;end&quot;], normalize=true, linewidth=0)</code></pre><img src="3a85a728.svg" alt="Example block output"/><p>The crucial difference compared to the bound defined from two distributions is that the start and end points are now placed symmetrically with respect to the band&#39;s peak position. The <code>UncertainBound</code> now &quot;follows&quot; the peak in each Monte-Carlo draw, so to speak.</p><h3 id="Defining-an-UncertainBound-using-several-positions,-a-width,-and-UncertainCurve-(several-symmetric-bands-with-same-width)"><a class="docs-heading-anchor" href="#Defining-an-UncertainBound-using-several-positions,-a-width,-and-UncertainCurve-(several-symmetric-bands-with-same-width)">Defining an <code>UncertainBound</code> using several positions, a width, and <code>UncertainCurve</code> (several symmetric bands with same width)</a><a id="Defining-an-UncertainBound-using-several-positions,-a-width,-and-UncertainCurve-(several-symmetric-bands-with-same-width)-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-an-UncertainBound-using-several-positions,-a-width,-and-UncertainCurve-(several-symmetric-bands-with-same-width)" title="Permalink"></a></h3><p>If, for example from a physical argument, we can say that two bands should have the same width, we can constrain our <code>UncertainBound</code>s even further: we can create several bounds that share the exact same integration window width in each draw.</p><p>All we have to do is to provide the constructor of <code>UncertainBound</code> not with a single position, but with an array of several positions:</p><pre><code class="language-julia hljs">positions = [15.0, 30.0]

wb_1, wb_2 = UncertainBound(positions, width_distribution, uncertain_spectrum)</code></pre><p>Note that the constructor will then return an array of <code>UncertainBound</code> objects which we unpacked into the variables <code>wb_1</code> and <code>wb_2</code> in the example above.</p><p>The histograms of the start and end points looks like this:</p><pre><code class="language-julia hljs">histogram( wb_1; label=[&quot;start 1&quot; &quot;end 1&quot;], normalize=true, linewidth=0)
histogram!(wb_2; label=[&quot;start 2&quot; &quot;end 2&quot;], normalize=true, linewidth=0)</code></pre><img src="838b0773.svg" alt="Example block output"/><p>It is not obvious from the histograms that the widths of the integration windows stored in <code>wb_1</code> and <code>wb_2</code> are identical, so we calculate and print them here manually to prove this:</p><pre><code class="language-julia hljs">for i in 1:10
    l1 = wb_1.left.particles[i]
    l2 = wb_2.left.particles[i]
    r1 = wb_1.right.particles[i]
    r2 = wb_2.right.particles[i]

    println(&quot;draw $i: width 1 = &quot;, r1 - l1, &quot; width 2 = &quot;, r2 - l2)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">draw 1: width 1 = 2.508220740749886 width 2 = 2.508220740749884
draw 2: width 1 = 2.3693963358500785 width 2 = 2.3693963358500767
draw 3: width 1 = 2.4979266547829138 width 2 = 2.4979266547829155
draw 4: width 1 = 2.3238679213036786 width 2 = 2.3238679213036804
draw 5: width 1 = 2.335871581391256 width 2 = 2.3358715813912525
draw 6: width 1 = 2.029793123091501 width 2 = 2.029793123091501
draw 7: width 1 = 2.692943688217433 width 2 = 2.692943688217433
draw 8: width 1 = 2.110326439755454 width 2 = 2.110326439755454
draw 9: width 1 = 2.517320261240366 width 2 = 2.5173202612403642
draw 10: width 1 = 2.13427868379193 width 2 = 2.1342786837919263</code></pre><div class="admonition is-warning"><header class="admonition-header">Watch out for the support of your width distribution</header><div class="admonition-body"><p>Note that the distribution that you pass to <code>UncertainBound</code> along with a position/positions must not allow for negative values (i.e. its support must end before 0). Keep in mind that a normal distribution, for example, has support from -∞ to ∞, so it is a poor choice here.</p></div></div><h2 id="plot_mc_draws"><a class="docs-heading-anchor" href="#plot_mc_draws">Plotting Monte-Carlo draws</a><a id="plot_mc_draws-1"></a><a class="docs-heading-anchor-permalink" href="#plot_mc_draws" title="Permalink"></a></h2><p>To verify that the integration windows and derived integrals are sensible, it is a good idea to plot a few draws and integrals before running the full Monte-Carlo algorithm. We can do so by passing an <code>UncertainCurve</code> and an array of <code>UncertainBound</code>s to the plot function:</p><pre><code class="language-julia hljs">plot(uncertain_spectrum, [wb_1, wb_2]; size=(400, 500), local_baseline=true)</code></pre><img src="78a895de.svg" alt="Example block output"/><p>We can see from the plot that our estimate for the width of the peaks was perhaps a bit too small, so we retry:</p><pre><code class="language-julia hljs">width_distribution = scale_shift_beta(2, 2, 3, 4) # width will fall in the range [3, 4]
wb_1, wb_2 = UncertainBound(positions, width_distribution, uncertain_spectrum)

plot(uncertain_spectrum, [wb_1, wb_2]; size=(400, 500), local_baseline=true)</code></pre><img src="c7f1d46a.svg" alt="Example block output"/><p>An alternative to the plot function is the <a href="../API/#NoisySignalIntegration.animate_draws"><code>animate_draws</code></a> function which allows you to visualize the Monte-Carlo draws in a gif animation:</p><pre><code class="language-julia hljs">NoisySignalIntegration.animate_draws(
    uncertain_spectrum, [wb_1, wb_2];
    size=(300, 150),
    local_baseline=true,
    draw_band_centers=true,
)</code></pre><img src="bb08d4e9.gif" alt="Example block output"/><p>The vertical lines are band centers (see <a href="../API/#NoisySignalIntegration.mc_bandcenter"><code>mc_bandcenter</code></a>), which are drawn if the keyword argument <code>draw_band_centers</code> is true.</p><h2 id="Running-the-integration-algorithm"><a class="docs-heading-anchor" href="#Running-the-integration-algorithm">Running the integration algorithm</a><a id="Running-the-integration-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-integration-algorithm" title="Permalink"></a></h2><p>The integration is performed with the function <a href="../API/#NoisySignalIntegration.mc_integrate"><code>mc_integrate</code></a>. We have to pass in the uncertain spectrum and integration bounds. Since we pass in two integration bounds, we retrieve two areas:</p><pre><code class="language-julia hljs">area_1, area_2 = mc_integrate(uncertain_spectrum, [wb_1, wb_2]; local_baseline=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{MonteCarloMeasurements.Particles{Float64, 50000}}:
 0.804 ± 0.13
 1.93 ± 0.13</code></pre><p>We can look at the histogram of the integrals:</p><pre><code class="language-julia hljs">histogram([area_1.particles, area_2.particles]; label=[&quot;band area 1&quot; &quot;band area 2&quot;])</code></pre><img src="57432139.svg" alt="Example block output"/><p>Or of the peak area ratio, simply by calculating with the retrieved areas:</p><pre><code class="language-julia hljs">ratio = area_1 / area_2
histogram(ratio.particles; label=&quot;band area ratio (band 1/band 2)&quot;)</code></pre><img src="105e9d2a.svg" alt="Example block output"/><p>We see that the histogram of peak area ratio peaks around 0.5, which is what we put into the simulation of the spectrum.</p><p>We can use some basic statistical functions to characterize the result:</p><div class="admonition is-info"><header class="admonition-header">Statistics on `MonteCarloMeasurements` uncertain numbers</header><div class="admonition-body"><p>To calculate statistics on uncertain numbers (which are implemented using the <code>MonteCarloMeasurements</code> package), you have to prefix the statistics function names with the letter <code>p</code>, e.g. <code>pmean()</code>, <code>pstd()</code>, etc., see the <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/stable/"><code>MonteCarloMeasurements</code> documentation</a>.</p></div></div><pre><code class="language-julia hljs">pmean(ratio)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.41792104677106023</code></pre><pre><code class="language-julia hljs">pstd(ratio)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.07488909421860397</code></pre><pre><code class="language-julia hljs">pquantile(ratio, 0.025)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.2760005180511169</code></pre><pre><code class="language-julia hljs">pquantile(ratio, 0.5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.4158723852463002</code></pre><pre><code class="language-julia hljs">pquantile(ratio, 0.975)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.570985589289268</code></pre><p>We find that, considering the noise and the uncertainty in the integration bounds, we end up with a 95% uncertainty interval of roughly 0.4 to 0.7.</p><div class="admonition is-info"><header class="admonition-header">Sensitivity analysis</header><div class="admonition-body"><p>It is perfectly valid to create several <code>UncertainBound</code>s for <em>one and the same band</em> and feed them into <code>mc_integrate()</code>, e.g. to perform a sensitivity analysis on how much the result depends on the kind and parameters of the bounds.</p></div></div><p>You find more usage examples on the next page. In particular, check out the <a href="../examples/#example_propagation">error propagation example</a> to see how to proceed with uncertainty calculations with the retrieved areas using <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl"><code>MonteCarloMeasurements.jl</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Package Overview</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 12 January 2024 19:35">Friday 12 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
